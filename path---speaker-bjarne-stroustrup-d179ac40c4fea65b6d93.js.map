{"version":3,"sources":["webpack:///path---speaker-bjarne-stroustrup-d179ac40c4fea65b6d93.js","webpack:///./.cache/json/speaker-bjarne-stroustrup.json"],"names":["webpackJsonp","1882","module","exports","data","allTalkJson","edges","node","description","meta","duration","presenter","name","source","id","provider","slug","tag","thumbnails","default","url","height","width","title","pathContext","speaker"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,aAAeC,QAAUC,MAAQC,YAAA,+/CAAAC,MAAwhDC,SAAA,cAAwBC,WAAcC,KAAA,qBAA2BC,QAAWC,GAAA,cAAAC,SAAA,WAAwCC,KAAA,2BAAAC,KAAA,+BAAAC,YAAuFC,SAAWC,IAAA,iDAAAC,OAAA,GAAAC,MAAA,MAAgFC,MAAA,kCAA2ChB,MAAQC,YAAA,m2BAAAC,MAA03BC,SAAA,cAAwBC,WAAcC,KAAA,qBAA2BC,QAAWC,GAAA,cAAAC,SAAA,WAAwCC,KAAA,2BAAAC,KAAA,uBAAAC,YAA+EC,SAAWC,IAAA,iDAAAC,OAAA,GAAAC,MAAA,MAAgFC,MAAA,iCAAyCC,aAAgBC,QAAA","file":"path---speaker-bjarne-stroustrup-d179ac40c4fea65b6d93.js","sourcesContent":["webpackJsonp([217808225846883],{\n\n/***/ 1882:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"allTalkJson\":{\"edges\":[{\"node\":{\"description\":\"We know how to write bad code: litter our programs with casts, macros, pointers, naked new and deletes, and complicated control structures. Alternatively (or additionally), we could obscure every design decision in a mess of deeply nested abstractions using the latest object-oriented programming and generic programming tricks. Then, for good measure, we might complicate our algorithms with interesting special cases. Such code is incomprehensible, unmaintainable, usually inefficient, and not uncommon.\\n\\nBut how do we write good code? What principles, techniques, and idioms can we exploit to make it easier to produce quality code? In this presentation, I make an argument for type-rich interfaces, compact data structures, integrated resource management and error handling, and highly-structured algorithmic code. I illustrate my ideas and guidelines with a few idiomatic code examples.\\n\\nI use C++11 freely. Examples include auto, general constant expressions, uniform initialization, type aliases, type safe threading, and user-defined literals. C++11 features are only just starting to appear in production compilers, so some of my suggestions are conjecture. Developing a \\\"modern style,\\\" however, is essential if we don't want to maintain newly-written 1970s and 1980s style code in 2020.\\n\\nThis presentation reflects my thoughts on what \\\"Modern C++\\\" should mean in the 2010s: a language for programming based on light-weight abstraction with direct and efficient mapping to hardware, suitable for infrastructure code.\",\"meta\":{\"duration\":\"PT1H29M48S\"},\"presenter\":{\"name\":\"Bjarne Stroustrup\"},\"source\":{\"id\":\"0iWb_qi2-uI\",\"provider\":\"youtube\"},\"slug\":\"keynote-goingnative-2012\",\"tag\":[\"C++\",\"GoingNative\",\"Keynote\"],\"thumbnails\":{\"default\":{\"url\":\"https://i.ytimg.com/vi/0iWb_qi2-uI/default.jpg\",\"height\":90,\"width\":120}},\"title\":\"Keynote GoingNative 2012 C++\"}},{\"node\":{\"description\":\"C++ faces two challenges: Helping programmers address the most demanding tasks in terms of performance, scale, and dependability. It must also help programmers be productive writing ordinary maintainable code. There is much more \\\"ordinary code\\\" than there is performance-critical code. Thus, C++ must make simple tasks simple while not getting in the way of tuning software for the last byte and last cycle where that's necessary. This talk focuses on what C++11 and C++14 offers to simplify programming: auto, range-for loops, move semantics, futures, concepts, and more. However, the focus is not primarily on language features: the key is programming: how can we write better, more readable, efficient, and more maintainable code? If you think that the essence of C++ is clever pointer manipulation and huge class hierarchies you may be in for a few surprises.\",\"meta\":{\"duration\":\"PT1H37M36S\"},\"presenter\":{\"name\":\"Bjarne Stroustrup\"},\"source\":{\"id\":\"nesCaocNjtQ\",\"provider\":\"youtube\"},\"slug\":\"make-simple-tasks-simple\",\"tag\":[\"CppCon\",\"Simplicity\"],\"thumbnails\":{\"default\":{\"url\":\"https://i.ytimg.com/vi/nesCaocNjtQ/default.jpg\",\"height\":90,\"width\":120}},\"title\":\"Make Simple Tasks Simple!\"}}]}},\"pathContext\":{\"speaker\":\"Bjarne Stroustrup\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---speaker-bjarne-stroustrup-d179ac40c4fea65b6d93.js","module.exports = {\"data\":{\"allTalkJson\":{\"edges\":[{\"node\":{\"description\":\"We know how to write bad code: litter our programs with casts, macros, pointers, naked new and deletes, and complicated control structures. Alternatively (or additionally), we could obscure every design decision in a mess of deeply nested abstractions using the latest object-oriented programming and generic programming tricks. Then, for good measure, we might complicate our algorithms with interesting special cases. Such code is incomprehensible, unmaintainable, usually inefficient, and not uncommon.\\n\\nBut how do we write good code? What principles, techniques, and idioms can we exploit to make it easier to produce quality code? In this presentation, I make an argument for type-rich interfaces, compact data structures, integrated resource management and error handling, and highly-structured algorithmic code. I illustrate my ideas and guidelines with a few idiomatic code examples.\\n\\nI use C++11 freely. Examples include auto, general constant expressions, uniform initialization, type aliases, type safe threading, and user-defined literals. C++11 features are only just starting to appear in production compilers, so some of my suggestions are conjecture. Developing a \\\"modern style,\\\" however, is essential if we don't want to maintain newly-written 1970s and 1980s style code in 2020.\\n\\nThis presentation reflects my thoughts on what \\\"Modern C++\\\" should mean in the 2010s: a language for programming based on light-weight abstraction with direct and efficient mapping to hardware, suitable for infrastructure code.\",\"meta\":{\"duration\":\"PT1H29M48S\"},\"presenter\":{\"name\":\"Bjarne Stroustrup\"},\"source\":{\"id\":\"0iWb_qi2-uI\",\"provider\":\"youtube\"},\"slug\":\"keynote-goingnative-2012\",\"tag\":[\"C++\",\"GoingNative\",\"Keynote\"],\"thumbnails\":{\"default\":{\"url\":\"https://i.ytimg.com/vi/0iWb_qi2-uI/default.jpg\",\"height\":90,\"width\":120}},\"title\":\"Keynote GoingNative 2012 C++\"}},{\"node\":{\"description\":\"C++ faces two challenges: Helping programmers address the most demanding tasks in terms of performance, scale, and dependability. It must also help programmers be productive writing ordinary maintainable code. There is much more \\\"ordinary code\\\" than there is performance-critical code. Thus, C++ must make simple tasks simple while not getting in the way of tuning software for the last byte and last cycle where that's necessary. This talk focuses on what C++11 and C++14 offers to simplify programming: auto, range-for loops, move semantics, futures, concepts, and more. However, the focus is not primarily on language features: the key is programming: how can we write better, more readable, efficient, and more maintainable code? If you think that the essence of C++ is clever pointer manipulation and huge class hierarchies you may be in for a few surprises.\",\"meta\":{\"duration\":\"PT1H37M36S\"},\"presenter\":{\"name\":\"Bjarne Stroustrup\"},\"source\":{\"id\":\"nesCaocNjtQ\",\"provider\":\"youtube\"},\"slug\":\"make-simple-tasks-simple\",\"tag\":[\"CppCon\",\"Simplicity\"],\"thumbnails\":{\"default\":{\"url\":\"https://i.ytimg.com/vi/nesCaocNjtQ/default.jpg\",\"height\":90,\"width\":120}},\"title\":\"Make Simple Tasks Simple!\"}}]}},\"pathContext\":{\"speaker\":\"Bjarne Stroustrup\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/speaker-bjarne-stroustrup.json\n// module id = 1882\n// module chunks = 217808225846883"],"sourceRoot":""}