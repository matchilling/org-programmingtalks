{"data":{"talkJson":{"description":"Architects draw detailed blueprints before a brick is laid or a nail is hammered. Programmers and software engineers seldom do. A blueprint for software is called a specification. The need for extremely rigorous specifications before coding complex or critical systems should be obvious—especially for concurrent and distributed systems. This talk explains why some sort of specification should be written for any software.\n\nhttp://www.microsoftfacultysummit.com","meta":{"duration":"PT59M51S"},"presenter":{"name":"Leslie Lamport"},"slug":"thinking-above-the-code","source":{"id":"-4Yp3j_jk8Q","provider":"youtube"},"tag":[],"title":"Thinking Above the Code"},"allTalkJson":{"edges":[{"node":{"description":"Architects draw detailed blueprints before a brick is laid or a nail is hammered. Programmers and software engineers seldom do. A blueprint for software is called a specification. The need for extremely rigorous specifications before coding complex or critical systems should be obvious—especially for concurrent and distributed systems. This talk explains why some sort of specification should be written for any software.\n\nhttp://www.microsoftfacultysummit.com","meta":{"duration":"PT59M51S"},"presenter":{"name":"Leslie Lamport"},"source":{"id":"-4Yp3j_jk8Q","provider":"youtube"},"slug":"thinking-above-the-code","tag":[],"thumbnails":{"default":{"url":"https://i.ytimg.com/vi/-4Yp3j_jk8Q/default.jpg","height":90,"width":120}},"title":"Thinking Above the Code"}},{"node":{"description":"In this keynote speech from JaxConf 2012, Rich Hickey, creator of Clojure and founder of Datomic gives an awesome analysis of the changing way we think about values (not the philosphoical kind) in light of the increasing complexity of information technology and the advent of Big Data. The broad subject of the talk makes it worth watching for almost anyone in the programming world, and was one of the highlights of the JaxConf lineup.","meta":{"duration":"PT31M44S"},"presenter":{"name":"Rich Hickey"},"source":{"id":"-6BsiVyC1kM","provider":"youtube"},"slug":"the-value-of-values","tag":["JaxConf 2012","Keynote"],"thumbnails":{"default":{"url":"https://i.ytimg.com/vi/-6BsiVyC1kM/default.jpg","height":90,"width":120}},"title":"The Value of Values"}},{"node":{"description":"Write your own compiler in 24 hours \nby Phil Trelford \n(@ptrelford) \n\nCompiler writers are often seen as the stuff of myth and legend.\n\nIn this session we'll step behind the proverbial curtain and reveal how compilers actually work.\n\nExpect plenty of live code samples, primarily in F#, covering language design and parsing, all-the-way through to emitting code. This session is aimed as a primer for those interested in writing an external DSL, general purpose language or just understanding how these things work.\n\nhttp://www.meetup.com/Norfolk-Developers-NorDev/events/205707742/","meta":{"duration":"PT1H4M8S"},"presenter":{"name":"Phil Trelford"},"source":{"id":"-E2tu3MqR24","provider":"youtube"},"slug":"write-your-own-compiler-in-24-hours","tag":["Compiler","F#","Windows","Write","DSL"],"thumbnails":{"default":{"url":"https://i.ytimg.com/vi/-E2tu3MqR24/default.jpg","height":90,"width":120}},"title":"Write your own compiler in 24 hours"}},{"node":{"description":"Probabilistic inference is a widely-used, rigorous approach for processing ambiguous information based on models that are uncertain or incomplete. However, models and inference algorithms can be difficult to specify and implement, let alone design, validate, or optimize. Additionally, inference often appears to be intractable. Probabilistic programming is an emerging field that aims to address these challenges by formalizing modeling and inference using key ideas from probability theory, programming languages, and Turing-universal computation.\n\nThis talk will illustrate the common underlying principles of probabilistic programming using three research platforms:\n\nBayesDB, a Bayesian database that enables users to directly query the probable implications of data tables without training in statistics. It provides BQL, an SQL-like language for Bayesian data analysis, and MML, a minimal language for building generative population models by combining automatic model-building techniques with qualitative constraints and custom statistical code. BayesDB has been applied to problems such as cleaning and exploring a public database of Earth satellites and assessing the evidence for microbial biomarkers of Kwashiorkor, a form of severe malnutrition.\n\nPicture, an imperative probabilistic language for 3D scene perception. Picture uses deep neural networks and statistical learning to invert generative models based on computer graphics. 50-line Picture programs can infer 3D models of human poses, faces, and other object classes from single images.\n\nVenture, an integrated platform that aims to be sufficiently expressive, efficient, and extensible for general-purpose use. It provides VentureScript, a language that gives users fine-grained control over both modeling and inference, and defines a common interface for integrating components written in other probabilistic languages. Recent applications include structure discovery from time-series via Gaussian processes and reflective AI techniques such as Bayesian optimization.\n\nVikash K. Mansinghka\nMIT\n\nVikash Mansinghka is a postdoctoral researcher at MIT, where he leads the Probabilistic Computing Project. Vikash holds S.B. degrees in Mathematics and in Computer Science from MIT, as well as an M.Eng. in Computer Science and a PhD in Computation. He also held graduate fellowships from the National Science Foundation and MIT's Lincoln Laboratory. His PhD dissertation on natively probabilistic computation won the MIT George M. Sprowls dissertation award in computer science, and his research on the Picture probabilistic programming language won an award at CVPR. He co-founded a venture-backed startup based on this research that was acquired by Salesforce.com and was an advisor to Google DeepMind. He served on DARPA's Information Science and Technology advisory board from 2010-2012, and currently serves on the editorial boards for the Journal of Machine Learning Research and the journal Statistics and Computation.","meta":{"duration":"PT1H2M55S"},"presenter":{"name":"Vikash K. Mansinghka"},"source":{"id":"-8QMqSWU76Q","provider":"youtube"},"slug":"an-overview-of-probabilistic-programming","tag":["Probabilistic Programming Language"],"thumbnails":{"default":{"url":"https://i.ytimg.com/vi/-8QMqSWU76Q/default.jpg","height":90,"width":120}},"title":"An Overview of Probabilistic Programming"}},{"node":{"description":"Rust aims to build a solid foundation for building safe software systems faster. We can ensure fewer mistakes enter our code base with immutability by default, no concept of null, and proven memory safety. Rust's state of the art compiler helps developers catch errors as early as possible without paying a penalty at runtime. Developers can write high level code in a modern language without sacrificing expressiveness, development time, or execution speed. We will explore how Rust's concept of Ownership is the key to providing compile-time safety. These guarantees apply even in the face of concurrency, allowing you to easily write multi-threaded programs correctly the first time. Rust 1.0 was released May 15th. Start building better software today.\n\nHelp us caption & translate this video!\n\nhttp://amara.org/v/HdB0/","meta":{"duration":"PT45M2S"},"presenter":{"name":"Alex Burkhart"},"source":{"id":"-dxqbhLIgdM","provider":"youtube"},"slug":"lambdaconf-2015-in-rust-we-trust","tag":["Rust","LambdaConf 2015"],"thumbnails":{"default":{"url":"https://i.ytimg.com/vi/-dxqbhLIgdM/default.jpg","height":90,"width":120}},"title":"In Rust We Trust"}},{"node":{"description":"Microsoft Computer Vision Summer School 2011.\nTalk by Victor Eruhimov about OpenCV.","meta":{"duration":"PT2H24M59S"},"presenter":{"name":"Victor Eruhimov"},"source":{"id":"0CNSCpcKiQ4","provider":"youtube"},"slug":"opencv-and-high-performance-vision-on-gpu","tag":["MSCVS2011","Computer Vision","opencv","summer school","Microsoft Research","MSU"],"thumbnails":{"default":{"url":"https://i.ytimg.com/vi/0CNSCpcKiQ4/default.jpg","height":90,"width":120}},"title":"OpenCV and High-Performance Vision on GPU"}},{"node":{"description":"Games are a modern art form, and like other artists, game designers need to experience their work as they create it. This talk will explore the benefits of making games \"at runtime\". Through both abstract discussion and concrete demonstration, we will see why Clojure is uniquely suited to the task.\n\nZach is an independent programmer and tutor in the Pittsburgh area. He made Nightcode, a Clojure IDE for beginners, and is working to make Clojure games a reality with the play-clj library and Nightmod, a game creation tool. Previously, he was a programmer at the National Security Agency in Maryland.","meta":{"duration":"PT37M34S"},"presenter":{"name":"Zach Oakes"},"source":{"id":"0GzzFeS5cMc","provider":"youtube"},"slug":"making-games-at-runtime-with-clojure","tag":["Clojure","Game Programmer"],"thumbnails":{"default":{"url":"https://i.ytimg.com/vi/0GzzFeS5cMc/default.jpg","height":90,"width":120}},"title":"Making Games at Runtime with Clojure"}},{"node":{"description":"http://www.cppcon.org\n—\nPresentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014\n--\nThere are numerous, serious OOP design problems that we have all encountered in production code. These include, among others: - object lifetime/ownership - how to make classes from different class hierarchies conform to a common interface - writing classes that can present multiple interfaces - separating interface and implementation - how to write virtual functions so that subclasses override them properly - the virtual inheritance \"diamond of death\"\n\nProper use of type erasure can mitigate, or outright eliminate, these and other problems, without sacrificing performance.\n\nThis talk will cover the OOP design problems above and more, and will cover hand-rolled and library-based type erasure approaches that solve those problems. Performance metrics will be provided for the different approaches, and source code will be available after the talk.\n--\nZach Laine has been using C++ in industry for 11 years, focusing on data visualization, numeric computing, games, generic programming, and good library design. He finds the process of writing bio blurbs to be a little uncomfortable.\n--\nVideos Filmed & Edited by Bash Films: http://www.BashFilms.com","meta":{"duration":"PT43M47S"},"presenter":{"name":"Zach Laine"},"source":{"id":"0I0FD3N5cgM","provider":"youtube"},"slug":"pragmatic-type-erasure-solving-oop-problems-with-elegant-design-pattern","tag":["CppCon 2014"],"thumbnails":{"default":{"url":"https://i.ytimg.com/vi/0I0FD3N5cgM/default.jpg","height":90,"width":120}},"title":"Pragmatic Type Erasure: Solving OOP Problems Elegant Design Pattern"}},{"node":{"description":"Writing operating systems sounds like it's only for wizards, but it turns out that operating systems are written by humans like you and me. I'm going to tell you what a kernel is and why you should care. Then we'll talk about a few concrete ways to get started with kernel hacking, ranging from the super-easy to the terrifyingly difficult.\n\nby Julia Evans (@b0rk) - Stripe\n\nJulia Evans loves taking apart systems to find how they work, making Serious Computer Programs do silly things, and organizing outreach events to make our developer communities a better place. She works on Stripe's data team.","meta":{"duration":"PT33M31S"},"presenter":{"name":null},"source":{"id":"0IQlpFWTFbM","provider":"youtube"},"slug":"you-can-be-a-kernel-hacker-by-julia-evans","tag":["Kernel","Operating System (Software Genre)"],"thumbnails":{"default":{"url":"https://i.ytimg.com/vi/0IQlpFWTFbM/default.jpg","height":90,"width":120}},"title":"\"You can be a kernel hacker!\" by Julia Evans"}},{"node":{"description":"We know how to write bad code: litter our programs with casts, macros, pointers, naked new and deletes, and complicated control structures. Alternatively (or additionally), we could obscure every design decision in a mess of deeply nested abstractions using the latest object-oriented programming and generic programming tricks. Then, for good measure, we might complicate our algorithms with interesting special cases. Such code is incomprehensible, unmaintainable, usually inefficient, and not uncommon.\n\nBut how do we write good code? What principles, techniques, and idioms can we exploit to make it easier to produce quality code? In this presentation, I make an argument for type-rich interfaces, compact data structures, integrated resource management and error handling, and highly-structured algorithmic code. I illustrate my ideas and guidelines with a few idiomatic code examples.\n\nI use C++11 freely. Examples include auto, general constant expressions, uniform initialization, type aliases, type safe threading, and user-defined literals. C++11 features are only just starting to appear in production compilers, so some of my suggestions are conjecture. Developing a \"modern style,\" however, is essential if we don't want to maintain newly-written 1970s and 1980s style code in 2020.\n\nThis presentation reflects my thoughts on what \"Modern C++\" should mean in the 2010s: a language for programming based on light-weight abstraction with direct and efficient mapping to hardware, suitable for infrastructure code.","meta":{"duration":"PT1H29M48S"},"presenter":{"name":"Bjarne Stroustrup"},"source":{"id":"0iWb_qi2-uI","provider":"youtube"},"slug":"keynote-goingnative-2012","tag":["C++","GoingNative","Keynote"],"thumbnails":{"default":{"url":"https://i.ytimg.com/vi/0iWb_qi2-uI/default.jpg","height":90,"width":120}},"title":"Keynote GoingNative 2012 C++"}}]}},"pageContext":{}}