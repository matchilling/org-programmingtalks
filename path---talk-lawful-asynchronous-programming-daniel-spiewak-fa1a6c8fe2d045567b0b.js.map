{"version":3,"sources":["webpack:///path---talk-lawful-asynchronous-programming-daniel-spiewak-fa1a6c8fe2d045567b0b.js","webpack:///./.cache/json/talk-lawful-asynchronous-programming-daniel-spiewak.json"],"names":["webpackJsonp","3039","module","exports","data","talkJson","description","meta","duration","presenter","name","slug","source","id","provider","tag","title","allTalkJson","edges","node","thumbnails","default","url","height","width","pathContext","tags"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,UAAYC,YAAA,klBAAAC,MAAwmBC,SAAA,aAAuBC,WAAcC,KAAA,MAAYC,KAAA,iDAAAC,QAAmEC,GAAA,cAAAC,SAAA,WAAwCC,KAAA,iDAAAC,MAAA,oDAAoHC,aAAgBC,QAAUC,MAAQb,YAAA,+kBAAAC,MAAqmBC,SAAA,YAAsBC,WAAcC,KAAA,MAAYE,QAAWC,GAAA,cAAAC,SAAA,WAAwCH,KAAA,6CAAAI,KAAA,gCAAAK,YAA0GC,SAAWC,IAAA,iDAAAC,OAAA,GAAAC,MAAA,MAAgFR,MAAA,kDAA2DG,MAAQb,YAAA,knCAAAC,MAAwoCC,SAAA,YAAsBC,WAAcC,KAAA,MAAYE,QAAWC,GAAA,cAAAC,SAAA,WAAwCH,KAAA,+CAAAI,KAAA,+DAAAK,YAA2IC,SAAWC,IAAA,iDAAAC,OAAA,GAAAC,MAAA,MAAgFR,MAAA,sDAA8DS,aAAgBd,KAAA,iDAAAe,MAAA","file":"path---talk-lawful-asynchronous-programming-daniel-spiewak-fa1a6c8fe2d045567b0b.js","sourcesContent":["webpackJsonp([101744971080563],{\n\n/***/ 3039:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"talkJson\":{\"description\":\"Laws are our friends! They make it easier to reason about things by eliminating possibilities and constraining the problem space. Applying lawful, principled and reasonable programming to the thorny problem of asynchronous and concurrent systems seems like a natural fit, but the devil is in the details.\\n\\nThis talk will explore scalaz-stream, both the present and the future designs at a very low-level. We'll look at where we can apply lawful reasoning and where we can't. We'll also examine some of our past failures in this area, and how we think we can do better in upcoming releases.\",\"meta\":{\"duration\":\"PT1H4M32S\"},\"presenter\":{\"name\":null},\"slug\":\"lawful-asynchronous-programming-daniel-spiewak\",\"source\":{\"id\":\"B0L91sW3XHw\",\"provider\":\"youtube\"},\"tag\":[\"Scala (Programming Language)\",\"asynchronicity\"],\"title\":\"Lawful Asynchronous Programming — Daniel Spiewak\"},\"allTalkJson\":{\"edges\":[{\"node\":{\"description\":\"The Scala standard library includes a large set of collections that covers a wide variety of use cases. For example, it offers both mutable and immutable collections, sequential and parallel collections, strict and lazy collections, and many combinations thereof.\\n\\nAlthough the standard collections library is widely used and works quite well today, this talk asks the question: how could the standard collections library be made better? We will look at various directions the Scala library could potentially evolve in the future, and discuss design trade-offs and migration strategies.\",\"meta\":{\"duration\":\"PT46M53S\"},\"presenter\":{\"name\":null},\"source\":{\"id\":\"UBjzbkhvYTU\",\"provider\":\"youtube\"},\"slug\":\"simplifying-scala-collections-bill-venners\",\"tag\":[\"Scala (Programming Language)\"],\"thumbnails\":{\"default\":{\"url\":\"https://i.ytimg.com/vi/UBjzbkhvYTU/default.jpg\",\"height\":90,\"width\":120}},\"title\":\"Simplifying Scala Collections — Bill Venners\"}},{\"node\":{\"description\":\"Idris is a general purpose pure functional programming language with dependent types. In Idris, types are a first class language construct, meaning that they can be manipulated and computed like any other language construct. It encourages a type-driven style of development, in which programmers give types first and use interactive editing tools to derive programs. Introductory examples typically involve length-preserving operations on lists, or ordering invariants on sorting.\\n\\nRealistically, though, programming is not so simple: programs interact with users, communicate over networks, manipulate state, deal with erroneous input, and so on. In this talk I will show how advanced type systems allow us to express such interactions precisely, and how they support verification of stateful systems as a result.\\n\\nThe talk will include several examples, leading to a verified implementation of a word game (Hangman). I will show how Type-driven Development allows programmers to specify the game rules in a direct and concise style, and how it leads to an implementation, guaranteed to correctly follow the rules by typechecking.\",\"meta\":{\"duration\":\"PT46M36S\"},\"presenter\":{\"name\":null},\"source\":{\"id\":\"X36ye-1x_HQ\",\"provider\":\"youtube\"},\"slug\":\"type-driven-development-in-idris-edwin-brady\",\"tag\":[\"Scala (Programming Language)\",\"Idris (Programming Language)\"],\"thumbnails\":{\"default\":{\"url\":\"https://i.ytimg.com/vi/X36ye-1x_HQ/default.jpg\",\"height\":90,\"width\":120}},\"title\":\"Type-Driven Development in Idris — Edwin Brady\"}}]}},\"pathContext\":{\"slug\":\"lawful-asynchronous-programming-daniel-spiewak\",\"tags\":[\"Scala (Programming Language)\",\"asynchronicity\"]}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---talk-lawful-asynchronous-programming-daniel-spiewak-fa1a6c8fe2d045567b0b.js","module.exports = {\"data\":{\"talkJson\":{\"description\":\"Laws are our friends! They make it easier to reason about things by eliminating possibilities and constraining the problem space. Applying lawful, principled and reasonable programming to the thorny problem of asynchronous and concurrent systems seems like a natural fit, but the devil is in the details.\\n\\nThis talk will explore scalaz-stream, both the present and the future designs at a very low-level. We'll look at where we can apply lawful reasoning and where we can't. We'll also examine some of our past failures in this area, and how we think we can do better in upcoming releases.\",\"meta\":{\"duration\":\"PT1H4M32S\"},\"presenter\":{\"name\":null},\"slug\":\"lawful-asynchronous-programming-daniel-spiewak\",\"source\":{\"id\":\"B0L91sW3XHw\",\"provider\":\"youtube\"},\"tag\":[\"Scala (Programming Language)\",\"asynchronicity\"],\"title\":\"Lawful Asynchronous Programming — Daniel Spiewak\"},\"allTalkJson\":{\"edges\":[{\"node\":{\"description\":\"The Scala standard library includes a large set of collections that covers a wide variety of use cases. For example, it offers both mutable and immutable collections, sequential and parallel collections, strict and lazy collections, and many combinations thereof.\\n\\nAlthough the standard collections library is widely used and works quite well today, this talk asks the question: how could the standard collections library be made better? We will look at various directions the Scala library could potentially evolve in the future, and discuss design trade-offs and migration strategies.\",\"meta\":{\"duration\":\"PT46M53S\"},\"presenter\":{\"name\":null},\"source\":{\"id\":\"UBjzbkhvYTU\",\"provider\":\"youtube\"},\"slug\":\"simplifying-scala-collections-bill-venners\",\"tag\":[\"Scala (Programming Language)\"],\"thumbnails\":{\"default\":{\"url\":\"https://i.ytimg.com/vi/UBjzbkhvYTU/default.jpg\",\"height\":90,\"width\":120}},\"title\":\"Simplifying Scala Collections — Bill Venners\"}},{\"node\":{\"description\":\"Idris is a general purpose pure functional programming language with dependent types. In Idris, types are a first class language construct, meaning that they can be manipulated and computed like any other language construct. It encourages a type-driven style of development, in which programmers give types first and use interactive editing tools to derive programs. Introductory examples typically involve length-preserving operations on lists, or ordering invariants on sorting.\\n\\nRealistically, though, programming is not so simple: programs interact with users, communicate over networks, manipulate state, deal with erroneous input, and so on. In this talk I will show how advanced type systems allow us to express such interactions precisely, and how they support verification of stateful systems as a result.\\n\\nThe talk will include several examples, leading to a verified implementation of a word game (Hangman). I will show how Type-driven Development allows programmers to specify the game rules in a direct and concise style, and how it leads to an implementation, guaranteed to correctly follow the rules by typechecking.\",\"meta\":{\"duration\":\"PT46M36S\"},\"presenter\":{\"name\":null},\"source\":{\"id\":\"X36ye-1x_HQ\",\"provider\":\"youtube\"},\"slug\":\"type-driven-development-in-idris-edwin-brady\",\"tag\":[\"Scala (Programming Language)\",\"Idris (Programming Language)\"],\"thumbnails\":{\"default\":{\"url\":\"https://i.ytimg.com/vi/X36ye-1x_HQ/default.jpg\",\"height\":90,\"width\":120}},\"title\":\"Type-Driven Development in Idris — Edwin Brady\"}}]}},\"pathContext\":{\"slug\":\"lawful-asynchronous-programming-daniel-spiewak\",\"tags\":[\"Scala (Programming Language)\",\"asynchronicity\"]}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/talk-lawful-asynchronous-programming-daniel-spiewak.json\n// module id = 3039\n// module chunks = 101744971080563"],"sourceRoot":""}