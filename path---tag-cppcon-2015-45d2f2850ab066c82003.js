webpackJsonp([0xd12eb662dc6b],{2125:function(e,t){e.exports={data:{allTalkJson:{edges:[{node:{description:"http://www.Cppcon.org\n—\nA primary use case for C++ is low latency, low overhead, high performance code. But C++ does not give you these things for free, it gives you the tools to control these things and achieve them where needed. How do you realize this potential of the language? How do you tune your C++ code and achieve the necessary performance metrics?\n\nThis talk will walk through the process of tuning C++ code from benchmarking to performance analysis. It will focus on small scale performance problems ranging from loop kernels to data structures and algorithms. It will show you how to write benchmarks that effectively measure different aspects of performance even in the face of advanced compiler optimizations and bedeviling modern CPUs. It will also show how to analyze the performance of your benchmark, understand its behavior as well as the CPUs behavior, and use a wide array of tools available to isolate and pinpoint performance problems. The tools and some processor details will be Linux and x86 specific, but the techniques and concepts should be broadly applicable.\n--\nChandler Carruth leads the Clang team at Google, building better diagnostics, tools, and more. Previously, he worked on several pieces of Google’s distributed build system. He makes guest appearances helping to maintain a few core C++ libraries across Google’s codebase, and is active in the LLVM and Clang open source communities. He received his M.S. and B.S. in Computer Science from Wake Forest University, but disavows all knowledge of the contents of his Master’s thesis. He is regularly found drinking Cherry Coke Zero in the daytime and pontificating over a single malt scotch in the evening.\n--\nVideos Filmed & Edited by Bash Films: http://www.BashFilms.com",meta:{duration:"PT1H29M54S"},presenter:{name:null},source:{id:"nXaxk27zwlk",provider:"youtube"},slug:"cppcon-2015-chandler-carruth-tuning-c-benchmarks-and-cpus-and-compilers-oh-my",tag:["CppCon 2015","Computer Science (Field)","Bash Films","Conference Video Recording","Event Video Recording","Video Conferencing","Video Services","Chandler Carruth"],thumbnails:{default:{url:"https://i.ytimg.com/vi/nXaxk27zwlk/default.jpg",height:90,width:120}},title:'CppCon 2015: Chandler Carruth "Tuning C++: Benchmarks, and CPUs, and Compilers! Oh My!"'}},{node:{description:"http://www.cppcon.org\n--\nThe standard library containers are often both misused and underused. Instead of creating new containers, applications are often structured with incidental data structures composed of objects referencing other object. This talk looks at some of the ways the standard containers can be better utilized and how creating (or using non-standard library) containers can greatly simplify code. The goal is no incidental data structures. \n--\nSean Parent is a principal scientist and software architect for Adobe’s mobile digital imaging group. Sean has been at Adobe since 1993 when he joined as a senior engineer working on Photoshop and later managed Adobe’s Software Technology Lab. In 2009 Sean spent a year at Google working on Chrome OS before returning to Adobe. From 1988 through 1993 Sean worked at Apple, where he was part of the system software team that developed the technologies allowing Apple’s successful transition to PowerPC.\n--\nVideos Filmed & Edited by Bash Films: http://www.BashFilms.com",meta:{duration:"PT1H4M"},presenter:{name:null},source:{id:"sWgDk-o-6ZE",provider:"youtube"},slug:"cppcon-2015-sean-parent-better-code-data-structures",tag:["CppCon 2015","Sean Parent","C++","Computer Programming (Conference Subject)","Data Structure (Literature Subject)","Bash Films","Conference Video","Video Services"],thumbnails:{default:{url:"https://i.ytimg.com/vi/sWgDk-o-6ZE/default.jpg",height:90,width:120}},title:'CppCon 2015: Sean Parent "Better Code: Data Structures"'}},{node:{description:'Transducers allow to express transformations on sequential inputs (like std::transform, std::filter, most of boost::range::adators and more) in a way that is independent of the input source. They are simple high order functions agnostic of the notion of iterator or collection and can be combined by simple function composition. They can later be applied eagerly or lazily over iterators, but most interestingly, also to other kinds of "reactive" sources, like networked streams, inter-process channels or reactive observables (e.g. RxCpp). Not only they provide an elegant decoupling between the "what" and the "how" and higher level of reuse, their implementation is often simpler and and more performant than similar boost::range adaptors.\n\nTransducers were introduced in Clojure by Rich Hickey. At Ableton we implemented them in C++ and released them as part of our Open Source modern C++ toolkit: Atria. Our implementation introduces innovations of its own, like implementing state-full transducers without mutation, enabling further safety and reusability. We also use Eric Niebler\'s technique to describe and check its concepts in standard compliant C++11.\n\nIn this session we will introduce the concept of transducers and how they can be implemented in modern C++.',meta:{duration:"PT1H4S"},presenter:{name:"Juan Pedro Bolívar Puente"},source:{id:"vohGJjGxtJQ",provider:"youtube"},slug:"transducers-from-clojure-to-c",tag:["Clojure","CppCon 2015"],thumbnails:{default:{url:"https://i.ytimg.com/vi/vohGJjGxtJQ/default.jpg",height:90,width:120}},title:"Transducers: from Clojure to C++"}}]}},pathContext:{slug:"cppcon-2015",tag:"CppCon 2015"}}}});
//# sourceMappingURL=path---tag-cppcon-2015-45d2f2850ab066c82003.js.map